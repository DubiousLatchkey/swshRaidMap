<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokemon Raid Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="styles/spritesheet.css" />
    <style>
        body {
            margin: 0;
            padding: 15px;
            font-family: Arial, sans-serif;
        }
        
        body.modal-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            margin: 10px 0 15px 0;
            font-size: 28px;
        }
        .filter-container {
            margin: 15px 0;
            padding: 12px;
            background-color: #f5f5f5;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        
        .filter-main-row {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
        }
        
        .pokemon-filter-section,
        .star-filter-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
            min-width: 300px;
        }
        
        .filter-container label {
            font-weight: bold;
            color: #333;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        .star-filter-container {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .star-button {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background-color: white;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            min-width: 60px;
            text-align: center;
        }
        
        .star-button:hover {
            border-color: #007cba;
            background-color: #f0f8ff;
        }
        
        .star-button.active {
            border-color: #007cba;
            background-color: #007cba;
            color: white;
        }
        
        .star-icon {
            color: #ffa500;
            font-weight: bold;
            text-shadow: 0 0 1px rgba(0,0,0,0.3);
        }
        
        .star-button.active .star-icon {
            color: #fff;
            text-shadow: 0 0 1px rgba(0,0,0,0.5);
        }
        
        .clear-stars-button {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f8f9fa;
            cursor: pointer;
            color: #666;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .clear-stars-button:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
        }
        .filter-status {
            margin-top: 10px;
            font-size: 14px;
            color: #666;
            font-style: italic;
            text-align: center;
        }
        .container {
            display: flex;
            gap: 20px;
            height: 75vh;
        }
        .map-container {
            flex: 1;
            position: relative;
        }
        .map-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .map {
            height: 100%;
            border: 2px solid #333;
            position: relative;
            background-color: #f0f0f0;
        }
        h2 {
            position: absolute;
            bottom: 10px;
            left: 10px;
            margin: 0;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            pointer-events: none;
        }

        .pokemon-sprite-container {
            display: inline-block;
            margin: 0;
            text-align: center;
            min-width: 0;
            width: 100%;
        }
        .pokemon-sprite {
            display: block;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            margin: 0 auto 2px auto;
            max-width: 100%;
            box-sizing: border-box;
        }
        .pokemon-sprite:hover {
            border-color: #007cba;
            background-color: #e7f3ff;
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(0, 124, 186, 0.3);
        }
        .pokemon-sprite.sword-exclusive {
            background-color: #0075BE;
            border-color: #005a9a;
        }
        .pokemon-sprite.sword-exclusive:hover {
            background-color: #0084d1;
            border-color: #0075BE;
        }
        .pokemon-sprite.shield-exclusive {
            background-color: #C62D42;
            border-color: #a02435;
        }
        .pokemon-sprite.shield-exclusive:hover {
            background-color: #d63851;
            border-color: #C62D42;
        }
        .rank-display {
            font-size: 10px;
            font-weight: bold;
            color: #333;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 3px;
            padding: 1px 3px;
            margin-top: 1px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            min-height: 12px;
            line-height: 12px;
            transition: all 0.2s ease;
        }
        
        .rank-display.filter-match {
            background-color: #22c55e;
            color: white;
            box-shadow: 0 2px 4px rgba(34, 197, 94, 0.4);
            font-weight: bold;
        }
        .popup-section {
            margin-bottom: 10px;
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: none;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        .modal-content {
            background: white;
            border-radius: 8px;
            max-width: 90vw;
            max-height: 90vh;
            position: relative;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .modal-header {
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 8px 8px 0 0;
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin: 0;
        }
        
        .modal-close {
            font-size: 24px;
            cursor: pointer;
            color: #666;
            background: none;
            border: none;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .modal-close:hover {
            color: #000;
            background-color: #e9ecef;
        }
        
        .modal-scroll-container {
            max-height: 70vh;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            -webkit-overflow-scrolling: touch;
        }
        
        .pokemon-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(96px, 1fr));
            gap: 8px;
            margin: 15px 0;
            max-width: 900px;
            justify-items: center;
            padding: 0 4px;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                flex-direction: column;
                height: auto;
                gap: 15px;
            }
            .map-container {
                height: 70vh;
                min-height: 350px;
                max-height: 700px;
                width: 100%;
                flex-shrink: 0;
            }
            .map {
                height: 100% !important;
                width: 100% !important;
                min-height: 280px;
            }

            .filter-container {
                padding: 10px;
                margin: 10px 0;
            }
            
            .filter-main-row {
                flex-direction: column;
                gap: 20px;
            }
            
            .pokemon-filter-section,
            .star-filter-section {
                min-width: auto;
                width: 100%;
                align-items: center;
            }
            
            .filter-container label {
                text-align: center;
                margin-bottom: 8px;
            }
            
            .pokemon-search-container {
                width: 100%;
                max-width: 300px;
                margin: 0 auto;
            }
            
            .filter-container select,
            .filter-container input {
                width: 100%;
                box-sizing: border-box;
            }
            
            .star-filter-container {
                justify-content: center;
                gap: 6px;
            }
            
            .star-button {
                min-width: 50px;
                padding: 6px 8px;
                font-size: 12px;
            }
            .pokemon-grid {
                grid-template-columns: repeat(auto-fill, minmax(75px, 1fr));
                gap: 6px;
                padding: 0 8px;
            }
            .modal-content {
                margin: 10px;
                max-height: 85vh;
            }
            
            .modal-header {
                padding: 12px 15px;
            }
            
            .modal-title {
                font-size: 16px;
            }
            
            .modal-scroll-container {
                padding: 15px;
                max-height: 65vh;
                -webkit-overflow-scrolling: touch;
            }
            .pokemon-sprite-container {
                margin: 0;
                width: 100%;
            }
            .rank-display {
                font-size: 9px;
                padding: 1px 2px;
            }
            
            .rank-display.filter-match {
                background-color: #22c55e;
                color: white;
                box-shadow: 0 1px 3px rgba(34, 197, 94, 0.4);
            }
            h1 {
                font-size: 22px;
                margin: 8px 0 12px 0;
            }
            h2 {
                font-size: 14px;
                bottom: 8px;
                left: 8px;
                padding: 6px 10px;
            }
        }
        
        /* Additional mobile improvements */
        @media (max-width: 480px) {
            .pokemon-grid {
                grid-template-columns: repeat(auto-fill, minmax(68px, 1fr));
                gap: 5px;
                padding: 0 6px;
            }
            .modal-content {
                margin: 5px;
                max-height: 90vh;
            }
            
            .modal-header {
                padding: 10px 12px;
            }
            
            .modal-title {
                font-size: 15px;
            }
            
            .modal-scroll-container {
                padding: 12px;
                max-height: 60vh;
                -webkit-overflow-scrolling: touch;
            }
            .rank-display {
                font-size: 8px;
                min-height: 10px;
                line-height: 10px;
            }
            
            .rank-display.filter-match {
                background-color: #22c55e;
                color: white;
                box-shadow: 0 1px 2px rgba(34, 197, 94, 0.4);
            }
            
            h2 {
                font-size: 12px;
                bottom: 6px;
                left: 6px;
                padding: 4px 8px;
            }
        }
        
        /* Pokemon search input styles */
        .pokemon-search-container {
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 300px;
        }
        
        .pokemon-search-input {
            width: 100%;
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: white;
            box-sizing: border-box;
        }
        
        .pokemon-search-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ccc;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10001;
            display: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }
        
        .pokemon-search-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        
        .pokemon-search-item:hover {
            background-color: #f0f0f0;
        }
        
        .pokemon-search-item:last-child {
            border-bottom: none;
        }
        
        /* Pokemon detail modal styles */
        .pokemon-detail-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 15000;
            display: none;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        .pokemon-detail-content {
            background: white;
            border-radius: 8px;
            max-width: 90vw;
            max-height: 80vh;
            position: relative;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            min-width: 300px;
        }
        
        @media (max-width: 768px) {
            .pokemon-detail-content {
                margin: 15px;
                min-width: auto;
                max-height: 75vh;
            }
        }
        

        
        .pokemon-detail-sprite {
            width: 96px;
            height: 96px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        
        .pokemon-detail-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        @media (max-width: 480px) {
            .pokemon-detail-info {
                grid-template-columns: 1fr;
                gap: 8px;
            }
        }
        
        .pokemon-detail-section {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            border-left: 4px solid #007cba;
        }
        
        .pokemon-detail-section h4 {
            margin: 0 0 8px 0;
            color: #333;
            font-size: 14px;
            font-weight: bold;
        }
        
        .pokemon-detail-section p {
            margin: 0;
            font-size: 13px;
            color: #666;
        }
        
        .clickable-sprite {
            cursor: pointer;
            transition: transform 0.1s ease;
        }
        
        .clickable-sprite:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <h1>Pokemon Raid Den Locations</h1>
    
    <div class="filter-container">
        <div class="filter-main-row">
            <div class="pokemon-filter-section">
                <label for="pokemonSearch">Filter by Pokemon:</label>
                <div class="pokemon-search-container">
                    <input type="text" id="pokemonSearch" class="pokemon-search-input" placeholder="Type Pokemon name...">
                    <div id="pokemonDropdown" class="pokemon-search-dropdown"></div>
                </div>
    </div>
    
            <div class="star-filter-section">
                <label>Filter by Stars:</label>
                <div class="star-filter-container">
                    <button class="star-button" data-star="1" onclick="toggleStarFilter(1)">
                        <span class="star-icon">★</span>
                    </button>
                    <button class="star-button" data-star="2" onclick="toggleStarFilter(2)">
                        <span class="star-icon">★★</span>
                    </button>
                    <button class="star-button" data-star="3" onclick="toggleStarFilter(3)">
                        <span class="star-icon">★★★</span>
                    </button>
                    <button class="star-button" data-star="4" onclick="toggleStarFilter(4)">
                        <span class="star-icon">★★★★</span>
                    </button>
                    <button class="star-button" data-star="5" onclick="toggleStarFilter(5)">
                        <span class="star-icon">★★★★★</span>
                    </button>
                    <button class="clear-stars-button" onclick="clearStarFilters()">Clear</button>
        </div>
        </div>
        </div>
    </div>
    

    
    <div class="container">
        <div class="map-container">
            <div class="map-wrapper">
            <div id="map1" class="map"></div>
                <h2>Wild Area</h2>
            </div>
        </div>
        <div class="map-container">
            <div class="map-wrapper">
            <div id="map2" class="map"></div>
                <h2>Isle of Armor</h2>
            </div>
        </div>
        <div class="map-container">
            <div class="map-wrapper">
            <div id="map3" class="map"></div>
                <h2>Crown Tundra</h2>
            </div>
        </div>
    </div>

    <!-- Modal for den information -->
    <div id="denModal" class="modal-overlay">
        <div class="modal-content">
            <div id="modalContent"></div>
        </div>
    </div>

    <!-- Modal for Pokemon details -->
    <div id="pokemonDetailModal" class="pokemon-detail-modal">
        <div class="pokemon-detail-content">
            <div id="pokemonDetailContent"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Load den, raid table, pokemon names, and gmax mapping data
        let denData = [];
        let raidTables = [];
        let pokemonNames = {};
        let gmaxMapping = {};
        let dataLoaded = 0;
        
        function checkDataLoaded() {
            if (dataLoaded === 4) {
                // Ensure DOM is ready before initializing maps
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', function() {
                        setTimeout(() => {
                initializeMaps();
                setupPokemonFilter();
                        }, 100);
                    });
                } else {
                    setTimeout(() => {
                        initializeMaps();
                        setupPokemonFilter();
                    }, 100);
                }
            }
        }
        
        fetch('data/den_locations.json')
            .then(response => response.json())
            .then(data => {
                denData = data;
                dataLoaded++;
                checkDataLoaded();
            })
            .catch(error => {
                console.error('Error loading den data:', error);
                denData = [];
                dataLoaded++;
                checkDataLoaded();
            });
            
        fetch('data/raid_tables.json')
            .then(response => response.json())
            .then(data => {
                raidTables = data;
                dataLoaded++;
                checkDataLoaded();
            })
            .catch(error => {
                console.error('Error loading raid tables:', error);
                raidTables = [];
                dataLoaded++;
                checkDataLoaded();
            });
            
        fetch('data/pokemon_names.json')
            .then(response => response.json())
            .then(data => {
                pokemonNames = data;
                dataLoaded++;
                checkDataLoaded();
            })
            .catch(error => {
                console.error('Error loading pokemon names:', error);
                pokemonNames = {};
                dataLoaded++;
                checkDataLoaded();
            });
            
        fetch('data/gmax_mapping.json')
            .then(response => response.json())
            .then(data => {
                gmaxMapping = data;
                dataLoaded++;
                checkDataLoaded();
            })
            .catch(error => {
                console.error('Error loading gmax mapping:', error);
                gmaxMapping = {};
                dataLoaded++;
                checkDataLoaded();
            });

        // Helper functions for raid data
        function getPokemonFromBothVersions(poolId) {
            const swordPool = raidTables.find(pool => pool.pool_id === poolId && pool.version === 1);
            const shieldPool = raidTables.find(pool => pool.pool_id === poolId && pool.version === 2);
            
            const swordPokemon = swordPool ? swordPool.pokemon.map(p => ({...p, version: 1})) : [];
            const shieldPokemon = shieldPool ? shieldPool.pokemon.map(p => ({...p, version: 2})) : [];
            
            return deduplicatePokemon(swordPokemon, shieldPokemon);
        }
        
        function deduplicatePokemon(swordPokemon, shieldPokemon) {
            const pokemonMap = new Map();
            
            // Create a unique key that includes all Pokemon attributes except probabilities
            function createPokemonKey(pokemon) {
                return `${pokemon.species}-${pokemon.altForm}-${pokemon.ability}-${pokemon.gender}-${pokemon.gigantamax}-${pokemon.flawlessIVs}-${pokemon.minRank}-${pokemon.maxRank}`;
            }
            
            // Add Sword Pokemon
            swordPokemon.forEach(pokemon => {
                const key = createPokemonKey(pokemon);
                pokemonMap.set(key, {
                    ...pokemon,
                    versions: [1],
                    exclusiveVersion: null,
                    swordRanks: { min: pokemon.minRank, max: pokemon.maxRank },
                    shieldRanks: null,
                    swordProbabilities: pokemon.Probabilities || pokemon.probabilities,
                    shieldProbabilities: null
                });
            });
            
            // Add Shield Pokemon, checking for duplicates
            shieldPokemon.forEach(pokemon => {
                const key = createPokemonKey(pokemon);
                if (pokemonMap.has(key)) {
                    // Pokemon exists in both versions with identical attributes (except probabilities)
                    const existing = pokemonMap.get(key);
                    existing.versions.push(2);
                    existing.shieldRanks = { min: pokemon.minRank, max: pokemon.maxRank };
                    existing.shieldProbabilities = pokemon.Probabilities || pokemon.probabilities;
                } else {
                    // Pokemon only in Shield or has different attributes
                    pokemonMap.set(key, {
                        ...pokemon,
                        versions: [2],
                        exclusiveVersion: 2,
                        swordRanks: null,
                        shieldRanks: { min: pokemon.minRank, max: pokemon.maxRank },
                        swordProbabilities: null,
                        shieldProbabilities: pokemon.Probabilities || pokemon.probabilities
                    });
                }
            });
            
            // Mark Sword exclusives
            pokemonMap.forEach((pokemon, key) => {
                if (pokemon.versions.length === 1 && pokemon.versions[0] === 1) {
                    pokemon.exclusiveVersion = 1;
                }
            });
            
            return Array.from(pokemonMap.values()).sort((a, b) => {
                // Get the highest max rank for each Pokemon (considering both versions)
                const aMaxRank = Math.max(
                    a.swordRanks ? a.swordRanks.max : -1,
                    a.shieldRanks ? a.shieldRanks.max : -1
                );
                const bMaxRank = Math.max(
                    b.swordRanks ? b.swordRanks.max : -1,
                    b.shieldRanks ? b.shieldRanks.max : -1
                );
                
                // Get the lowest min rank for each Pokemon (considering both versions)
                const aMinRank = Math.min(
                    a.swordRanks ? a.swordRanks.min : Infinity,
                    a.shieldRanks ? a.shieldRanks.min : Infinity
                );
                const bMinRank = Math.min(
                    b.swordRanks ? b.swordRanks.min : Infinity,
                    b.shieldRanks ? b.shieldRanks.min : Infinity
                );
                
                // Sort by max rank first, then min rank, then species ID
                if (aMaxRank !== bMaxRank) {
                    return aMaxRank - bMaxRank;
                }
                if (aMinRank !== bMinRank) {
                    return aMinRank - bMinRank;
                }
                return a.species - b.species;
            });
        }
        
        function pokemonMatchesCurrentFilters(pokemon) {
            const hasFilters = currentFilter || selectedStars.size > 0;
            if (!hasFilters) {
                return false; // No highlighting when no filters active
            }
            
            const pokemonId = currentFilter ? parseInt(currentFilter) : null;
            const hasStarFilter = selectedStars.size > 0;
            
            // Check Pokemon species match
            let pokemonMatches = true;
            if (pokemonId) {
                pokemonMatches = pokemon.species === pokemonId;
            }
            
            // Check star rank match
            let starMatches = true;
            if (hasStarFilter) {
                const selectedRanks = Array.from(selectedStars).map(star => star - 1);
                let pokemonRanks = [];
                
                // Get all ranks this Pokemon can appear at
                if (pokemon.swordRanks && typeof pokemon.swordRanks === 'object') {
                    for (let rank = pokemon.swordRanks.min; rank <= pokemon.swordRanks.max; rank++) {
                        if (!pokemonRanks.includes(rank)) {
                            pokemonRanks.push(rank);
                        }
                    }
                }
                if (pokemon.shieldRanks && typeof pokemon.shieldRanks === 'object') {
                    for (let rank = pokemon.shieldRanks.min; rank <= pokemon.shieldRanks.max; rank++) {
                        if (!pokemonRanks.includes(rank)) {
                            pokemonRanks.push(rank);
                        }
                    }
                }
                
                // Fallback: direct minRank/maxRank
                if (pokemon.minRank !== undefined && pokemon.maxRank !== undefined) {
                    for (let rank = pokemon.minRank; rank <= pokemon.maxRank; rank++) {
                        if (!pokemonRanks.includes(rank)) {
                            pokemonRanks.push(rank);
                        }
                    }
                }
                
                starMatches = selectedRanks.some(selectedRank => pokemonRanks.includes(selectedRank));
            }
            
            return pokemonMatches && starMatches;
        }
        
        function createPokemonSprite(pokemon) {
            const speciesId = pokemon.species;
            
            // Determine sprite number - use Gmax mapping if this is a Gigantamax form
            let spriteNumber = speciesId;
            if (pokemon.gigantamax && gmaxMapping[speciesId]) {
                spriteNumber = gmaxMapping[speciesId];
            }
            
            const exclusiveClass = pokemon.exclusiveVersion === 1 ? 'sword-exclusive' : 
                                 pokemon.exclusiveVersion === 2 ? 'shield-exclusive' : '';
            
            // Format rank display (add 1 since data is 0-indexed but game is 1-indexed)
            function formatRanks(minRank, maxRank) {
                const displayMin = minRank + 1;
                const displayMax = maxRank + 1;
                return displayMin === displayMax ? `${displayMin}☆` : `${displayMin}☆-${displayMax}☆`;
            }
            
            let rankDisplay = '';
            
            if (pokemon.swordRanks && pokemon.shieldRanks) {
                // Pokemon in both versions
                const swordRanksStr = formatRanks(pokemon.swordRanks.min, pokemon.swordRanks.max);
                const shieldRanksStr = formatRanks(pokemon.shieldRanks.min, pokemon.shieldRanks.max);
                
                if (swordRanksStr === shieldRanksStr) {
                    // Same ranks in both versions
                    rankDisplay = swordRanksStr;
                } else {
                    // Different ranks
                    rankDisplay = `S:${swordRanksStr} Sh:${shieldRanksStr}`;
                }
            } else if (pokemon.swordRanks) {
                // Sword only
                rankDisplay = formatRanks(pokemon.swordRanks.min, pokemon.swordRanks.max);
            } else if (pokemon.shieldRanks) {
                // Shield only
                rankDisplay = formatRanks(pokemon.shieldRanks.min, pokemon.shieldRanks.max);
            }
            
            // Check if this Pokemon matches the current filters
            const matchesFilter = pokemonMatchesCurrentFilters(pokemon);
            const highlightClass = matchesFilter ? 'filter-match' : '';
            
            // Create unique ID for this pokemon instance
            const pokemonInstanceId = `pokemon-${speciesId}-${pokemon.altForm || 0}-${pokemon.gigantamax ? 'gmax' : 'normal'}-${Date.now()}-${Math.random()}`;
            
            return `
                <div class="pokemon-sprite-container">
                    <div class="sprite-${spriteNumber} pokemon-sprite ${exclusiveClass} clickable-sprite" 
                         onclick="openPokemonDetailModal(${JSON.stringify(pokemon).replace(/"/g, '&quot;')})"
                         data-pokemon-id="${pokemonInstanceId}"></div>
                    <div class="rank-display ${highlightClass}">${rankDisplay}</div>
                </div>
            `;
        }
        
        function createPokemonGrid(pokemonList, title) {
            if (!pokemonList || pokemonList.length === 0) {
                return `<div class="popup-section"><h3 style="margin: 10px 0 15px 0; color: #333;">${title}</h3><p>No Pokemon data available</p></div>`;
            }
            
            const sprites = pokemonList.map(p => createPokemonSprite(p)).join('');
            
            return `
                <div class="popup-section">
                    <h3 style="margin: 10px 0 15px 0; color: #333; border-bottom: 2px solid #e0e0e0; padding-bottom: 8px;">
                        ${title}
                    </h3>
                    <div class="pokemon-grid">${sprites}</div>
                </div>
            `;
        }
        
        function createDenPopup(den, index) {
            const commonPokemon = getPokemonFromBothVersions(den.common_pool);
            const rarePokemon = getPokemonFromBothVersions(den.rare_pool);
            
            return `
                <div style="font-size: 16px;">
                    ${createPokemonGrid(commonPokemon, `Common Pool (#${den.common_pool})`)}
                    ${createPokemonGrid(rarePokemon, `Rare Pool (#${den.rare_pool})`)}
                </div>
            `;
        }
        
        // Store current modal data for refreshing when filters change
        let currentModalDen = null;
        let currentModalIndex = null;
        
        // Modal functions
        function openModal(content, title = 'Raid Den', den = null, index = null) {
            currentModalDen = den;
            currentModalIndex = index;
            
            document.getElementById('modalContent').innerHTML = `
                <div class="modal-header">
                    <h3 class="modal-title">${title}</h3>
                    <button class="modal-close" onclick="closeModal()">&times;</button>
                </div>
                <div class="modal-scroll-container">
                    ${content}
                </div>
            `;
            document.body.classList.add('modal-open');
            document.getElementById('denModal').style.display = 'flex';
        }
        
        function closeModal() {
            document.getElementById('denModal').style.display = 'none';
            document.body.classList.remove('modal-open');
            currentModalDen = null;
            currentModalIndex = null;
        }
        
        function refreshModalIfOpen() {
            if (currentModalDen && currentModalIndex !== null && 
                document.getElementById('denModal').style.display === 'flex') {
                // Regenerate content with current filters
                const content = createDenPopup(currentModalDen, currentModalIndex);
                const title = `Den #${currentModalIndex + 1}`;
                
                // Update modal content without changing the open state
                document.getElementById('modalContent').innerHTML = `
                    <div class="modal-header">
                        <h3 class="modal-title">${title}</h3>
                        <button class="modal-close" onclick="closeModal()">&times;</button>
                    </div>
                    <div class="modal-scroll-container">
                        ${content}
                    </div>
                `;
            }
        }
        
        // Pokemon detail modal functions
        function openPokemonDetailModal(pokemon) {
            const speciesId = pokemon.species;
            const pokemonName = capitalizePokemonName(pokemonNames[speciesId] || `Pokemon #${speciesId}`);
            const content = createPokemonDetailContent(pokemon);
            
            document.getElementById('pokemonDetailContent').innerHTML = `
                <div class="modal-header">
                    <h3 class="modal-title">${pokemonName}</h3>
                    <button class="modal-close" onclick="closePokemonDetailModal()">&times;</button>
                </div>
                <div class="modal-scroll-container">
                    ${content}
                </div>
            `;
            document.body.classList.add('modal-open');
            document.getElementById('pokemonDetailModal').style.display = 'flex';
        }
        
        function closePokemonDetailModal() {
            document.getElementById('pokemonDetailModal').style.display = 'none';
            document.body.classList.remove('modal-open');
        }
        
        function createPokemonDetailContent(pokemon) {
            const speciesId = pokemon.species;
            
            // Determine sprite number - use Gmax mapping if this is a Gigantamax form
            let spriteNumber = speciesId;
            if (pokemon.gigantamax && gmaxMapping[speciesId]) {
                spriteNumber = gmaxMapping[speciesId];
            }
            
            // Version info
            const versionText = pokemon.exclusiveVersion === 1 ? 'Sword Only' : 
                              pokemon.exclusiveVersion === 2 ? 'Shield Only' : 
                              'Both Versions';
            const versionColor = pokemon.exclusiveVersion === 1 ? '#0075BE' : 
                               pokemon.exclusiveVersion === 2 ? '#C62D42' : '#666';
            
            // Format rank display
            function formatRanks(minRank, maxRank) {
                const displayMin = minRank + 1;
                const displayMax = maxRank + 1;
                return displayMin === displayMax ? `${displayMin}☆` : `${displayMin}☆-${displayMax}☆`;
            }
            
            // Format probability information
            function formatProbabilities(probArray, versionName) {
                if (!probArray || !Array.isArray(probArray)) return '';
                const probText = probArray
                    .map((prob, index) => ({ star: index + 1, prob }))
                    .filter(item => item.prob > 0)
                    .map(item => `${item.star}☆: ${item.prob}%`)
                    .join(', ');
                return probText ? `<strong>${versionName}:</strong> ${probText}` : '';
            }
            
            // Build sections
            let sections = [];
            
            // Basic info section
            let basicInfo = [];
            if (pokemon.altForm && pokemon.altForm > 0) {
                basicInfo.push(`<p>Alternative Form: ${pokemon.altForm}</p>`);
            }
            if (pokemon.gigantamax) {
                basicInfo.push(`<p>Gigantamax Form Available</p>`);
            }
            if (pokemon.gender === 1) {
                basicInfo.push(`<p>Gender: Male Only</p>`);
            } else if (pokemon.gender === 2) {
                basicInfo.push(`<p>Gender: Female Only</p>`);
            } else {
                basicInfo.push(`<p>Gender: Any</p>`);
            }
            if (pokemon.flawlessIVs) {
                basicInfo.push(`<p>Guaranteed Perfect IVs: ${pokemon.flawlessIVs}</p>`);
            }
            
            if (basicInfo.length > 0) {
                sections.push(`
                    <div class="pokemon-detail-section">
                        <h4>Basic Information</h4>
                        ${basicInfo.join('')}
                    </div>
                `);
            }
            

            
            // Probability information
            let probInfo = [];
            const swordProbs = formatProbabilities(pokemon.swordProbabilities, 'Sword');
            const shieldProbs = formatProbabilities(pokemon.shieldProbabilities, 'Shield');
            
            if (swordProbs) probInfo.push(`<p>${swordProbs}</p>`);
            if (shieldProbs) probInfo.push(`<p>${shieldProbs}</p>`);
            
            if (probInfo.length > 0) {
                sections.push(`
                    <div class="pokemon-detail-section">
                        <h4>Spawn Probabilities</h4>
                        ${probInfo.join('')}
                    </div>
                `);
            }
            
            return `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div class="sprite-${spriteNumber} pokemon-detail-sprite" style="margin: 0 auto 15px auto;"></div>
                    <p style="margin: 0; font-size: 16px; color: #666;">#${speciesId}</p>
                    <p style="margin: 5px 0 0 0; font-size: 14px; color: ${versionColor}; font-weight: bold;">${versionText}</p>
                </div>
                <div class="pokemon-detail-info">
                    ${sections.join('')}
                </div>
            `;
        }
        
        // Close modal when clicking outside of it
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('denModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeModal();
                }
            });
            
            document.getElementById('pokemonDetailModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closePokemonDetailModal();
                }
            });
            
            // Close modal with Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeModal();
                    closePokemonDetailModal();
                }
            });
            
            // Prevent modal content from propagating clicks to overlay
            document.addEventListener('click', function(e) {
                const modalContent = e.target.closest('.modal-content');
                const pokemonContent = e.target.closest('.pokemon-detail-content');
                if (modalContent || pokemonContent) {
                    e.stopPropagation();
                }
            });
        });

        // Pokemon filter setup
        let allMarkers = []; // Store all markers for filtering
        let pokemonList = []; // Store Pokemon list for search
        let currentFilter = ''; // Store current filter value
        let selectedStars = new Set(); // Store selected star filters
        
        function setupPokemonFilter() {
            const searchInput = document.getElementById('pokemonSearch');
            const dropdown = document.getElementById('pokemonDropdown');
            
            // Create array of pokemon with names for sorting
            pokemonList = Object.entries(pokemonNames).map(([id, name]) => ({
                id: parseInt(id),
                name: name,
                searchText: `${name.toLowerCase()}`
            }));
            
            // Sort alphabetically by name
            pokemonList.sort((a, b) => a.name.localeCompare(b.name));
            
            // Add event listeners for search functionality
            searchInput.addEventListener('input', function() {
                const query = this.value.toLowerCase().trim();
                if (query.length > 0) {
                    showFilteredPokemon(query);
                } else {
                    hideDropdown();
                    if (currentFilter) {
                        currentFilter = '';
                        applyFilters();
                    }
                }
            });
            
            searchInput.addEventListener('blur', function() {
                // Delay hiding dropdown to allow for clicks
                setTimeout(() => hideDropdown(), 150);
            });
            
            searchInput.addEventListener('focus', function() {
                const query = this.value.toLowerCase().trim();
                showFilteredPokemon(query);
            });
            
            // Add clear button functionality
            searchInput.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    this.value = '';
                    hideDropdown();
                    if (currentFilter) {
                        currentFilter = '';
                        applyFilters();
                    }
                }
            });
        }
        
        function capitalizePokemonName(name) {
            return name.split(' ').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            ).join(' ');
        }
        
        function showFilteredPokemon(query) {
            const dropdown = document.getElementById('pokemonDropdown');
            let filteredPokemon;
            
            if (query.length === 0) {
                // Show all Pokemon when no query
                filteredPokemon = pokemonList;
            } else {
                // Filter when user types
                filteredPokemon = pokemonList.filter(pokemon => 
                    pokemon.searchText.includes(query) || 
                    pokemon.id.toString() === query
                );
            }
            
            if (filteredPokemon.length > 0) {
                dropdown.innerHTML = filteredPokemon.map(pokemon => {
                    const capitalizedName = capitalizePokemonName(pokemon.name);
                    return `<div class="pokemon-search-item" onclick="selectPokemon(${pokemon.id}, '${pokemon.name.replace(/'/g, "\\'")}')">
                        ${capitalizedName}
                    </div>`;
                }).join('');
                dropdown.style.display = 'block';
            } else {
                dropdown.innerHTML = '<div class="pokemon-search-item">No Pokemon found</div>';
                dropdown.style.display = 'block';
            }
        }
        
        function hideDropdown() {
            document.getElementById('pokemonDropdown').style.display = 'none';
        }
        
        function selectPokemon(pokemonId, pokemonName) {
            const searchInput = document.getElementById('pokemonSearch');
            searchInput.value = capitalizePokemonName(pokemonName);
            hideDropdown();
            currentFilter = pokemonId.toString();
            applyFilters();
        }
        
        function clearFilter() {
            currentFilter = '';
            filterDensByPokemon('');
        }
        
        // Star filter functions
        function toggleStarFilter(star) {
            const button = document.querySelector(`[data-star="${star}"]`);
            
            if (selectedStars.has(star)) {
                selectedStars.delete(star);
                button.classList.remove('active');
            } else {
                selectedStars.add(star);
                button.classList.add('active');
            }
            
            applyFilters();
        }
        
        function clearStarFilters() {
            selectedStars.clear();
            document.querySelectorAll('.star-button').forEach(button => {
                button.classList.remove('active');
            });
            applyFilters();
        }
        
        function applyFilters() {
            // Apply both Pokemon name filter and star filter
            filterDensByFilters();
            
            // Refresh modal content if it's currently open
            refreshModalIfOpen();
        }
        
        function filterDensByFilters() {
            const pokemonId = currentFilter ? parseInt(currentFilter) : null;
            const hasStarFilter = selectedStars.size > 0;
            
            if (!pokemonId && !hasStarFilter) {
                // Show all markers with original styling
                allMarkers.forEach(marker => {
                    marker.setStyle({
                        fillColor: '#ff0000',
                        color: '#ffffff',
                        opacity: 1,
                        fillOpacity: 0.8,
                        weight: 2
                    });
                });
                updateFilterStatus({total: allMarkers.length}, allMarkers.length);
                return;
            }
            
            let counts = { common: 0, rare: 0, both: 0, total: 0 };
            const pokemonName = pokemonId ? pokemonNames[pokemonId] : null;
            
            allMarkers.forEach(marker => {
                const den = marker.denData;
                let denMatches = false;
                let pokemonResult = null;
                
                if (pokemonId && hasStarFilter) {
                    // Both Pokemon and star filters active - check if specific Pokemon has the selected ranks
                    denMatches = denContainsPokemonAtStarRanks(den, pokemonId, selectedStars);
                    if (denMatches) {
                        pokemonResult = denContainsPokemon(den, pokemonId); // For color coding
                    }
                } else if (pokemonId && !hasStarFilter) {
                    // Only Pokemon filter
                    pokemonResult = denContainsPokemon(den, pokemonId);
                    denMatches = pokemonResult.hasPokemon;
                } else if (!pokemonId && hasStarFilter) {
                    // Only star filter - any Pokemon at selected ranks
                    denMatches = denContainsStarRanks(den, selectedStars);
                }
                
                if (denMatches) {
                    counts.total++;
                    let fillColor, borderColor;
                    
                    if (pokemonResult && pokemonResult.hasPokemon) {
                        // Show Pokemon pool colors
                        switch (pokemonResult.poolType) {
                        case 'common':
                                fillColor = '#ff0000';
                            borderColor = '#cc0000';
                            counts.common++;
                            break;
                        case 'rare':
                                fillColor = '#8b00ff';
                            borderColor = '#6600cc';
                            counts.rare++;
                            break;
                        case 'both':
                                fillColor = '#ff0000';
                                borderColor = '#8b00ff';
                            counts.both++;
                            break;
                        }
                    } else {
                        // Default styling for star-only filter
                        fillColor = '#ff0000';
                        borderColor = '#cc0000';
                    }
                    
                    marker.setStyle({
                        fillColor: fillColor,
                        color: borderColor,
                        opacity: 1,
                        fillOpacity: 0.9,
                        weight: 3
                    });
                } else {
                    // Faded styling for non-matching dens
                    marker.setStyle({
                        fillColor: '#cccccc',
                        color: '#999999',
                        opacity: 0.3,
                        fillOpacity: 0.2,
                        weight: 1
                    });
                }
            });
            
            updateFilterStatus(counts, allMarkers.length, pokemonName, selectedStars);
        }
        
        function denContainsPokemonAtStarRanks(den, pokemonId, starSet) {
            const commonPokemon = getPokemonFromBothVersions(den.common_pool);
            const rarePokemon = getPokemonFromBothVersions(den.rare_pool);
            const allPokemon = [...commonPokemon, ...rarePokemon];
            
            // Convert stars to ranks for comparison
            const selectedRanks = Array.from(starSet).map(star => star - 1);
            
            // Find the specific Pokemon in this den
            const targetPokemon = allPokemon.filter(pokemon => pokemon.species === pokemonId);
            
            if (targetPokemon.length === 0) {
                return false; // Pokemon not in this den
            }
            
            // Check if any instance of this Pokemon has the selected ranks
            for (let pokemon of targetPokemon) {
                let pokemonRanks = [];
                
                // Get all ranks this Pokemon can appear at
                if (pokemon.swordRanks && typeof pokemon.swordRanks === 'object') {
                    for (let rank = pokemon.swordRanks.min; rank <= pokemon.swordRanks.max; rank++) {
                        if (!pokemonRanks.includes(rank)) {
                            pokemonRanks.push(rank);
                        }
                    }
                }
                if (pokemon.shieldRanks && typeof pokemon.shieldRanks === 'object') {
                    for (let rank = pokemon.shieldRanks.min; rank <= pokemon.shieldRanks.max; rank++) {
                        if (!pokemonRanks.includes(rank)) {
                            pokemonRanks.push(rank);
                        }
                    }
                }
                
                // Fallback: direct minRank/maxRank
                if (pokemon.minRank !== undefined && pokemon.maxRank !== undefined) {
                    for (let rank = pokemon.minRank; rank <= pokemon.maxRank; rank++) {
                        if (!pokemonRanks.includes(rank)) {
                            pokemonRanks.push(rank);
                        }
                    }
                }
                
                // Check if this Pokemon instance has any of the selected ranks
                const hasMatch = selectedRanks.some(selectedRank => pokemonRanks.includes(selectedRank));
                
                if (hasMatch) {
                    return true;
                }
            }
            
            return false; // Pokemon found but not at selected ranks
        }
        
        function denContainsStarRanks(den, starSet) {
            const commonPokemon = getPokemonFromBothVersions(den.common_pool);
            const rarePokemon = getPokemonFromBothVersions(den.rare_pool);
            const allPokemon = [...commonPokemon, ...rarePokemon];
            
            // Convert stars to ranks for comparison
            const selectedRanks = Array.from(starSet).map(star => star - 1);
            
            // Check if ANY Pokemon in the den has the selected ranks
            for (let pokemon of allPokemon) {
                let pokemonRanks = [];
                
                if (pokemon.swordRanks && typeof pokemon.swordRanks === 'object') {
                    for (let rank = pokemon.swordRanks.min; rank <= pokemon.swordRanks.max; rank++) {
                        if (!pokemonRanks.includes(rank)) {
                            pokemonRanks.push(rank);
                        }
                    }
                }
                if (pokemon.shieldRanks && typeof pokemon.shieldRanks === 'object') {
                    for (let rank = pokemon.shieldRanks.min; rank <= pokemon.shieldRanks.max; rank++) {
                        if (!pokemonRanks.includes(rank)) {
                            pokemonRanks.push(rank);
                        }
                    }
                }
                
                if (pokemon.minRank !== undefined && pokemon.maxRank !== undefined) {
                    for (let rank = pokemon.minRank; rank <= pokemon.maxRank; rank++) {
                        if (!pokemonRanks.includes(rank)) {
                            pokemonRanks.push(rank);
                        }
                    }
                }
                
                const hasMatch = selectedRanks.some(selectedRank => pokemonRanks.includes(selectedRank));
                if (hasMatch) {
                    return true;
                }
            }
            
            return false;
        }
        
        function filterDensByPokemon(selectedPokemonId) {
            currentFilter = selectedPokemonId;
            applyFilters();
        }
        
        function updateFilterStatus(counts, total, pokemonName = null, starSet = null) {
            const filterContainer = document.querySelector('.filter-container');
            
            // Remove existing status
            const existingStatus = filterContainer.querySelector('.filter-status');
            if (existingStatus) {
                existingStatus.remove();
            }
            
            // Add new status if filtering
            if (pokemonName || (starSet && starSet.size > 0)) {
                const status = document.createElement('div');
                status.className = 'filter-status';
                
                // Handle counts properly - extract total from object or use counts directly
                const totalCount = (typeof counts === 'object' && counts.total !== undefined) ? counts.total : counts;
                let statusText = `Showing ${totalCount} of ${total} dens`;
                
                const filters = [];
                if (pokemonName) {
                    filters.push(`<strong>${pokemonName}</strong>`);
                }
                if (starSet && starSet.size > 0) {
                    const starText = Array.from(starSet).sort((a, b) => a - b).map(s => `${s}☆`).join(', ');
                    filters.push(`<strong>${starText}</strong>`);
                }
                
                if (filters.length > 0) {
                    statusText += ` with ${filters.join(' and ')}`;
                }
                
                status.innerHTML = statusText;
                filterContainer.appendChild(status);
            }
        }
        
        function denContainsPokemon(den, pokemonId) {
            const commonPokemon = getPokemonFromBothVersions(den.common_pool);
            const rarePokemon = getPokemonFromBothVersions(den.rare_pool);
            
            const inCommon = commonPokemon.some(pokemon => pokemon.species === pokemonId);
            const inRare = rarePokemon.some(pokemon => pokemon.species === pokemonId);
            
            return {
                hasPokemon: inCommon || inRare,
                inCommon: inCommon,
                inRare: inRare,
                poolType: inCommon && inRare ? 'both' : (inCommon ? 'common' : (inRare ? 'rare' : 'none'))
            };
        }

        // Store map instances for resizing
        let mapInstances = [];

        // Initialize maps
        function initMap(mapId, imagePath, denLocations) {
            const map = L.map(mapId, {
                crs: L.CRS.Simple,
                minZoom: -2,
                maxZoom: 3
            });

            // Store map instance for later use
            mapInstances.push(map);

            // Create image overlay with proper bounds
            const img = new Image();
            img.onload = function() {
                const imageWidth = this.width;
                const imageHeight = this.height;
                const imageBounds = [[0, 0], [imageHeight, imageWidth]];
                
                L.imageOverlay(imagePath, imageBounds).addTo(map);
                map.fitBounds(imageBounds);
                
                // Force map to recalculate size after image loads
                setTimeout(() => {
                    map.invalidateSize();
                }, 100);
                
                // Add den markers after image loads
                denLocations.forEach((den, index) => {
                    // Convert coordinates (Y is inverted for Leaflet)
                    const lat = imageHeight - den.MapY;
                    const lng = den.MapX;
                    
                    const marker = L.circleMarker([lat, lng], {
                        radius: 8,
                        fillColor: '#ff0000',
                        color: '#ffffff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8
                    }).addTo(map);
                    
                    // Store den data with marker for filtering
                    marker.denData = den;
                    allMarkers.push(marker);
                    
                    marker.on('click', function() {
                        openModal(createDenPopup(den, index), `Den #${index + 1}`, den, index);
                    });
                });
            };
            img.src = imagePath;

            return map;
        }

        function initializeMaps() {
            // Separate den data by location
            const wildAreaDens = denData.filter(den => den.location < 17);
            const ioaDens = denData.filter(den => den.location >= 17 && den.location < 32);
            const ctDens = denData.filter(den => den.location >= 32);

            // Initialize all three maps
            const map1 = initMap('map1', 'images/map.png', wildAreaDens);
            const map2 = initMap('map2', 'images/map_ioa.png', ioaDens);
            const map3 = initMap('map3', 'images/map_tc.png', ctDens);

            // Add resize handler for mobile layout changes
            let resizeTimeout;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(function() {
                    mapInstances.forEach(map => {
                        map.invalidateSize();
                    });
                }, 250);
            });

            // Handle orientation change specifically for mobile
            window.addEventListener('orientationchange', function() {
                setTimeout(function() {
                    mapInstances.forEach(map => {
                        map.invalidateSize();
                    });
                }, 500);
            });

            // Additional resize check after DOM is fully loaded
            setTimeout(function() {
                mapInstances.forEach(map => {
                    map.invalidateSize();
                });
            }, 1000);

            // Media query change handler for mobile/desktop transitions
            if (window.matchMedia) {
                const mediaQuery = window.matchMedia('(max-width: 768px)');
                mediaQuery.addListener(function(mq) {
                    setTimeout(function() {
                        mapInstances.forEach(map => {
                            map.invalidateSize();
                        });
                    }, 300);
                });
            }

            // Intersection Observer to resize maps when they become visible
            if (window.IntersectionObserver) {
                const observer = new IntersectionObserver(function(entries) {
                    entries.forEach(function(entry) {
                        if (entry.isIntersecting) {
                            const mapElement = entry.target.querySelector('.map');
                            if (mapElement) {
                                const mapId = mapElement.id;
                                const mapInstance = mapInstances.find(map => 
                                    map.getContainer().id === mapId
                                );
                                if (mapInstance) {
                                    setTimeout(() => {
                                        mapInstance.invalidateSize();
                                    }, 100);
                                }
                            }
                        }
                    });
                }, {
                    threshold: 0.1
                });

                document.querySelectorAll('.map-container').forEach(function(container) {
                    observer.observe(container);
                });
            }

            // Fallback: Force map refresh if mobile layout issues persist
            setTimeout(function() {
                if (window.innerWidth <= 768) {
                    mapInstances.forEach(map => {
                        try {
                            map.invalidateSize();
                            // Force a re-fit to bounds if map seems empty
                            const bounds = map.getBounds();
                            if (bounds) {
                                map.fitBounds(bounds);
                            }
                        } catch (e) {
                            console.log('Map resize fallback attempted');
                        }
                    });
                }
            }, 2000);
        }
    </script>
</body>
</html> 